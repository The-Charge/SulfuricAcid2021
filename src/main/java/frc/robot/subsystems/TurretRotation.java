// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpiutil.math.MathUtil;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class TurretRotation extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX turretMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Used for degree control
    private static final double DEGREE_TOLERANCE = 0.5;
    private static final double DEGREE_MAX_PERCENT = 0.3;
    private static final double DEGREE_MIN_PERCENT = 0.05;
    private static final double DEGREE_PERCENT_SCALE = 1 / 40;

    // TODO: tune degrees per tick
    private static final double TICKS_PER_DEGREE = 0;

    // Encoder constants
    private static final double MIN_ENCODER_TICKS = -482070;
    private static final double MAX_ENCODER_TICKS = 484191;

    // Used for absolute normalized [-1, 1] control
    private static final double NORMALIZED_TOLERANCE = 0.2;
    private static final double NORMALIZED_PERCENT = 0.3;

    /**
    *
    */
    public TurretRotation() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        turretMotor = new WPI_TalonSRX(7);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        turretMotor.set(ControlMode.PercentOutput, 0);
        turretMotor.setSelectedSensorPosition(0);
        turretMotor.setNeutralMode(NeutralMode.Brake);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        checkLimitSwitches();
        SmartDashboard.putNumber("Turret Rotation/currentTicks", turretMotor.getSelectedSensorPosition());
        SmartDashboard.putNumber("Turret Rotation/currentAngle", currentAngle());
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public double currentAngle() {
        return turretMotor.getSelectedSensorPosition() / TICKS_PER_DEGREE;
    }

    public void setRawPercent(double percent) {
        turretMotor.set(percent);
    }

    /**
     * Checks whether the turret is at a limit switch, and if so will reset the
     * encoder value
     * 
     * @return true if the turret is at a limit switch
     */
    public boolean checkLimitSwitches() {
        if (turretMotor.getSensorCollection().isRevLimitSwitchClosed()) {
            turretMotor.setSelectedSensorPosition((int) MIN_ENCODER_TICKS, 0, 10);
            return true;
        } else if (turretMotor.getSensorCollection().isFwdLimitSwitchClosed()) {
            turretMotor.setSelectedSensorPosition((int) MAX_ENCODER_TICKS, 0, 10);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Rotates the turret to a relative angle using a bang-bang controller. Must be
     * called repeatedly from somewhere else
     * 
     * @param angle in degrees
     * @return true if the angle is less than the tolerance
     */
    public boolean turnToRelativeAngle(double angle) {
        if (Math.abs(angle) < DEGREE_TOLERANCE) {
            turretMotor.set(0);
            return true;
        } else {
            double percent = DEGREE_PERCENT_SCALE * Math.abs(angle);
            percent = MathUtil.clamp(percent, DEGREE_MIN_PERCENT, DEGREE_MAX_PERCENT);
            percent = Math.signum(angle) * percent;
            percent = -percent; // Motor is inverted (I think)
            turretMotor.set(percent);
            return false;
        }
    }

    /**
     * Moves the turret at a constant speed to a targeted absolute position. Must be
     * called repeatedly from somewhere else
     * 
     * @param setpoint the target position on the range [-1 (left), 1 (right)]
     * @return true if the error is less than the tolerance
     */
    public boolean gotoPosition(double setpoint) {
        // Normalize current location between [-1, 1]
        double ticks = turretMotor.getSelectedSensorPosition();
        double current = (ticks < 0) ? ticks / Math.abs(MIN_ENCODER_TICKS) : ticks / MAX_ENCODER_TICKS;

        double error = current - setpoint;
        if (Math.abs(error) < NORMALIZED_TOLERANCE) {
            turretMotor.set(0);
            return true;
        } else {
            turretMotor.set(Math.signum(error) * NORMALIZED_PERCENT);
            return false;
        }
    }
}
