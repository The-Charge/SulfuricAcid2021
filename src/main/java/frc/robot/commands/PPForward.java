// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Date;
import java.util.List;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj.controller.RamseteController;
import edu.wpi.first.wpilibj.controller.SimpleMotorFeedforward;
import edu.wpi.first.wpilibj.geometry.Pose2d;
import edu.wpi.first.wpilibj.geometry.Rotation2d;
import edu.wpi.first.wpilibj.geometry.Transform2d;
import edu.wpi.first.wpilibj.geometry.Translation2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.trajectory.Trajectory;
import edu.wpi.first.wpilibj.trajectory.TrajectoryConfig;
import edu.wpi.first.wpilibj.trajectory.TrajectoryGenerator;
import edu.wpi.first.wpilibj.trajectory.TrajectoryUtil;
import edu.wpi.first.wpilibj.trajectory.constraint.DifferentialDriveVoltageConstraint;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.ConditionalCommand;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.ParallelCommandGroup;
import edu.wpi.first.wpilibj2.command.ParallelRaceGroup;
import edu.wpi.first.wpilibj2.command.RamseteCommand;
import edu.wpi.first.wpilibj2.command.RunCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.WaitCommand;
import frc.robot.Robot;
import frc.robot.RobotContainer;
import frc.robot.Constants.AutoConstants;
import frc.robot.Constants.DriveConstants;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.Drivetrain;
import frc.robot.subsystems.Indexer;
import frc.robot.subsystems.Intake;
import frc.robot.subsystems.Shooter;
import frc.robot.subsystems.Stopper;
import frc.robot.subsystems.Turret;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class PPForward extends SequentialCommandGroup {

    Drivetrain m_drivetrain;
    Intake m_intake;
    Indexer m_indexer;
    Shooter m_shooter;
    Stopper m_stopper;
    Turret m_turret;
    AutonCommandFactory factory;

    public static final double MAXVEL = 2.0;
    public static final double MAXACC = 0.9;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    public PPForward(Drivetrain drivetrain, Stopper stopper, Indexer indexer, Shooter shooter, Turret turret,
            Intake intake) {

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_drivetrain = drivetrain;
        m_intake = intake;
        m_indexer = indexer;
        m_shooter = shooter;
        m_stopper = stopper;
        m_turret = turret;
        // m_intake = intake;
        // m_
        
    }

    @Override
    public void initialize() {
        // TODO Auto-generated method stub
        factory = new AutonCommandFactory();

        // RobotContainer.ctrPP += 1;

        System.out.println("============================================================");
        System.out.println("BEFORE SD");
        System.out.println("============================================================");

        SmartDashboard.putNumber("COUNTER", RobotContainer.ctrPP);
        SmartDashboard.putString("TIMESTAMP", (new Date()).toString());

        System.out.println("AFTER SD");
        System.out.println("============================================================");

        // addCommands(
        // new ConditionalCommand(

        // )
        // );

        if (RobotContainer.ctrPP != 1) {
            System.out.println("NOT 1");
            System.out.println("============================================================");
            addCommands(

                    new ParallelRaceGroup(
                            new ParallelCommandGroup(new Shoot(0.8, m_shooter), new RunTurretVision(m_turret, 0.75)),
                            new SequentialCommandGroup(factory.reset(Math.PI, m_drivetrain), getAutonomous(true),
                                    factory.launch(3, m_stopper, m_indexer))),
                    factory.reset(0, m_drivetrain),
                    new ParallelRaceGroup(getAutonomous(false), new RunCommand(() -> m_turret.runHorizontalManual(0))),
                    factory.runIntakeIndex(m_intake, m_indexer));
        } else {
            System.out.println("IS 1");
            System.out.println("============================================================");
            addCommands(
                    new ParallelRaceGroup(
                            new ParallelCommandGroup(new Shoot(0.8, m_shooter), new RunTurretVision(m_turret, 0.75)),
                            new WaitCommand(2).andThen(factory.launch(3, m_stopper, m_indexer))),
                    factory.reset(0, m_drivetrain),
                    new ParallelRaceGroup(getAutonomous(false), new RunCommand(() -> m_turret.runHorizontalManual(0))),
                    factory.runIntakeIndex(m_intake, m_indexer));
        }

        System.out.println("VERY END");
        System.out.println("============================================================");
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }


    private Command getAutonomous(boolean reversed) {
        var autoVoltageConstraint = new DifferentialDriveVoltageConstraint(
                new SimpleMotorFeedforward(DriveConstants.ksVolts, DriveConstants.kvVoltSecondsPerMeter,
                        DriveConstants.kaVoltSecondsSquaredPerMeter),
                DriveConstants.kDriveKinematics, 10);

        TrajectoryConfig config = new TrajectoryConfig(MAXVEL, MAXACC).setKinematics(DriveConstants.kDriveKinematics)
                .addConstraint(autoVoltageConstraint);

        config.setReversed(reversed);

        Trajectory trajectory;
        if (reversed) {
            trajectory = TrajectoryGenerator.generateTrajectory(
                    // Start at the origin facing the +X direction
                    new Pose2d(0, 0, new Rotation2d(Math.PI)), List.of(), new Pose2d(2.5, 0, new Rotation2d(Math.PI)),
                    config);
        } else {
            trajectory = TrajectoryGenerator.generateTrajectory(
                    // Start at the origin facing the +X direction
                    new Pose2d(0, 0, new Rotation2d(0)), List.of(), new Pose2d(2.5, 0, new Rotation2d(0)), config);
        }

        RamseteCommand ramseteCommand = new RamseteCommand(trajectory, m_drivetrain::getPose,
                new RamseteController(AutoConstants.kRamseteB, AutoConstants.kRamseteZeta),
                new SimpleMotorFeedforward(DriveConstants.ksVolts, DriveConstants.kvVoltSecondsPerMeter,
                        DriveConstants.kaVoltSecondsSquaredPerMeter),
                DriveConstants.kDriveKinematics, m_drivetrain::getWheelSpeeds,
                new PIDController(DriveConstants.kPDriveVel, 0, 0), new PIDController(DriveConstants.kPDriveVel, 0, 0),
                m_drivetrain::tankDriveVolts, m_drivetrain);

        m_drivetrain.resetOdometry(trajectory.getInitialPose());

        return ramseteCommand;
    }

    // Called once after isFinished returns true
    @Override
    public void end(boolean interrupted) {
        m_indexer.stop();
        m_intake.stop();

        System.out.println();
        System.out.println();
        System.out.println();

        System.out.println(interrupted);
        System.out.println(RobotContainer.ctrPP);

        System.out.println();
        System.out.println();
        System.out.println();
    }
}
