// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj.controller.RamseteController;
import edu.wpi.first.wpilibj.controller.SimpleMotorFeedforward;
import edu.wpi.first.wpilibj.geometry.Pose2d;
import edu.wpi.first.wpilibj.geometry.Rotation2d;
import edu.wpi.first.wpilibj.geometry.Transform2d;
import edu.wpi.first.wpilibj.geometry.Translation2d;
import edu.wpi.first.wpilibj.trajectory.Trajectory;
import edu.wpi.first.wpilibj.trajectory.TrajectoryConfig;
import edu.wpi.first.wpilibj.trajectory.TrajectoryGenerator;
import edu.wpi.first.wpilibj.trajectory.TrajectoryUtil;
import edu.wpi.first.wpilibj.trajectory.constraint.DifferentialDriveVoltageConstraint;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.ParallelCommandGroup;
import edu.wpi.first.wpilibj2.command.ParallelRaceGroup;
import edu.wpi.first.wpilibj2.command.RamseteCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.WaitCommand;
import frc.robot.Constants.AutoConstants;
import frc.robot.Constants.DriveConstants;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.Drivetrain;
import frc.robot.subsystems.Indexer;
import frc.robot.subsystems.Intake;
import frc.robot.subsystems.Shooter;
import frc.robot.subsystems.Stopper;
import frc.robot.subsystems.Turret;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class PPForward extends SequentialCommandGroup {

    Drivetrain m_drivetrain;
    AutonCommandFactory factory;

    public static final double MAXVEL = 2.0;
    public static final double MAXACC = 0.9;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    public PPForward(Drivetrain drivetrain, Stopper stopper, Indexer indexer, Shooter shooter, Turret turret, Intake intake){

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_drivetrain = drivetrain;
        factory = new AutonCommandFactory();

        addCommands(
            new ParallelRaceGroup(
                // Constantly run shooter and turret
                new ParallelCommandGroup(
                    new Shoot(0.8, shooter),
                    new RunTurretVision(turret, 0.8)
                ),
                new SequentialCommandGroup(
                    // Prepare for movement
                    new InstantCommand(() -> drivetrain.resetOdometry(new Pose2d(0,0, new Rotation2d(Math.PI)))),
                    new InstantCommand(drivetrain::resetEncoders),
                    // Move
                    getAutonomous(true),
                    new OpenStopper(stopper),
                    // Shoot when in position
                    new ParallelRaceGroup(
                        new WaitCommand(3),
                        new Index(indexer, 0.5, true)
                    )
                )
            ),
            new CloseStopper(stopper, indexer),
            new InstantCommand(() -> drivetrain.resetOdometry(new Pose2d(0,0, new Rotation2d(0)))),
            new InstantCommand(drivetrain::resetEncoders),
            // Move
            getAutonomous(false),
            parallel(
                new RunIntake(intake, 0.5),
                new Index(indexer, 0.5)
            )

        );

        // addCommands(
        //     new ParallelRaceGroup(
        //         new Shoot(0.8, shooter),
        //         new RunTurretVision(turret, 0.8),
        //         new InstantCommand(() -> drivetrain.resetOdometry(new Pose2d(0,0, new Rotation2d(Math.PI)))),
        //         new InstantCommand(drivetrain::resetEncoders),
        //         getAutonomous(),
        //         new OpenStopper(stopper),
        //         new ParallelRaceGroup(
        //             new WaitCommand(3),
        //             new Shoot(0.8,shooter),
        //             new Index(indexer, 0.5, true)
        //         )
        //     )
        // );
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }

    private Command getAutonomous(boolean reversed) {
        var autoVoltageConstraint =
            new DifferentialDriveVoltageConstraint(
                new SimpleMotorFeedforward(DriveConstants.ksVolts, 
                                           DriveConstants.kvVoltSecondsPerMeter, 
                                           DriveConstants.kaVoltSecondsSquaredPerMeter),
                DriveConstants.kDriveKinematics,
                10);
    
        TrajectoryConfig config =
            new TrajectoryConfig(MAXVEL, 
                                 MAXACC)
                .setKinematics(DriveConstants.kDriveKinematics)
                .addConstraint(autoVoltageConstraint);
    
        config.setReversed(reversed);
        
        Trajectory trajectory;
        if (reversed){
            trajectory = TrajectoryGenerator.generateTrajectory(
            // Start at the origin facing the +X direction
            new Pose2d(0, 0, new Rotation2d(Math.PI)),
            List.of(),
            new Pose2d(2.5, 0, new Rotation2d(Math.PI)),
            config);
        }else {
            trajectory = TrajectoryGenerator.generateTrajectory(
            // Start at the origin facing the +X direction
            new Pose2d(0, 0, new Rotation2d(0)),
            List.of(),
            new Pose2d(2.5, 0, new Rotation2d(0)),
            config);
        }
    
        RamseteCommand ramseteCommand = new RamseteCommand(
            trajectory,
            m_drivetrain::getPose,
            new RamseteController(AutoConstants.kRamseteB, AutoConstants.kRamseteZeta),
            new SimpleMotorFeedforward(DriveConstants.ksVolts, DriveConstants.kvVoltSecondsPerMeter, DriveConstants.kaVoltSecondsSquaredPerMeter),
            DriveConstants.kDriveKinematics,
            m_drivetrain::getWheelSpeeds,
            new PIDController(DriveConstants.kPDriveVel, 0, 0),
            new PIDController(DriveConstants.kPDriveVel, 0, 0),
            m_drivetrain::tankDriveVolts,
            m_drivetrain);
    
        m_drivetrain.resetOdometry(trajectory.getInitialPose());
    
        return ramseteCommand;
      } 
    
}
