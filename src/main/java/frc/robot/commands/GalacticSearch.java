// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj.controller.RamseteController;
import edu.wpi.first.wpilibj.controller.SimpleMotorFeedforward;
import edu.wpi.first.wpilibj.geometry.Pose2d;
import edu.wpi.first.wpilibj.geometry.Rotation2d;
import edu.wpi.first.wpilibj.geometry.Transform2d;
import edu.wpi.first.wpilibj.geometry.Translation2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.trajectory.Trajectory;
import edu.wpi.first.wpilibj.trajectory.TrajectoryConfig;
import edu.wpi.first.wpilibj.trajectory.TrajectoryGenerator;
import edu.wpi.first.wpilibj.trajectory.TrajectoryUtil;
import edu.wpi.first.wpilibj.trajectory.constraint.DifferentialDriveVoltageConstraint;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.ConditionalCommand;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.ParallelRaceGroup;
import edu.wpi.first.wpilibj2.command.RamseteCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import frc.robot.RobotContainer;
import frc.robot.Constants.AutoConstants;
import frc.robot.Constants.DriveConstants;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.Drivetrain;
import frc.robot.subsystems.Indexer;
import frc.robot.subsystems.Intake;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class GalacticSearch extends SequentialCommandGroup {

    Drivetrain m_drivetrain;
    AutonCommandFactory factory;

    private static double VELOCITY = 1.5;
    private static double ACCELERATION = 0.5;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    public GalacticSearch(Drivetrain drivetrain, Intake intake, Indexer indexer){
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        m_drivetrain = drivetrain;
        factory = new AutonCommandFactory();

        addCommands(
            parallel(
                factory.getIntakeIndexer(intake, indexer),
                new InstantCommand(() -> m_drivetrain.resetOdometry(new Pose2d(0, 0, new Rotation2d(0)))).andThen(
                new ConditionalCommand(

                    // Red A
                    getSegment(
                        new Pose2d(0, 0, new Rotation2d(0)),
                        new Pose2d(7.6, 1.4, new Rotation2d(0)),
                        List.of(new Translation2d(1,0), new Translation2d(2.6,-0.5), new Translation2d(3.5,1.1)),
                        false
                    ),

                    new ConditionalCommand(

                        // Red B
                        getSegment(
                            new Pose2d(0, 0, new Rotation2d(0)),
                            new Pose2d(7.6, 0.8, new Rotation2d(0)),
                            List.of(new Translation2d(1.5,0.8), new Translation2d(3,-0.8), new Translation2d(4.5, 0.5)),
                            false
                        ),

                        new ConditionalCommand(

                            // Blue A
                            getSegment(
                                new Pose2d(0, 0, new Rotation2d(0)),
                                new Pose2d(7.6, -0.8, new Rotation2d(-Math.PI/4)),
                                List.of(new Translation2d(3.8, -1.4), new Translation2d(4.5, 0.8), new Translation2d(6.1, 0)),
                                false
                            ),

                            // Blue B
                            getSegment(
                                new Pose2d(0, 0, new Rotation2d(0)),
                                // new Pose2d(7.6, 1.6, new Rotation2d(-Math.PI/4)),
                                new Pose2d(8, -0.8, new Rotation2d(0)),
                                List.of(
                                    new Translation2d(3.8, -0.7),
                                    new Translation2d(5.5, 0.7),
                                    new Translation2d(7, -0.9)
                                ),
                                false
                            ),

                            () -> SmartDashboard.getString("Vision/path", "").equals("a-blue")),
                        () -> SmartDashboard.getString("Vision/path", "").equals("b-red")),
                    () -> SmartDashboard.getString("Vision/path", "").equals("a-red")
                )
                )
            )
        );

        // String path = SmartDashboard.getString("Vision/path", "");
        // String filename = "";
        // if (path.equals("a-red")) {
        //     filename = "galacticRedA";
        // } else if (path.equals("b-red")) {
        //     filename = "galacticRedB";
        // } else if (path.equals("a-blue")) {
        //     filename = "galacticBlueA";
        // } else if (path.equals("b-blue")) {
        //     filename = "galacticBlueB";
        // } else if (path.equals("")) {
        //     filename = "";
        //     System.out.println("    Path not detected");
        // } else {
        //     filename = "";
        //     System.out.println("    Unknown path for locations " + path);
        // }

        // //filename = "g";
        // if (filename.equals("galacticRedA")) {
        //     addCommands(
        //         parallel(
        //             factory.getIntakeIndexer(intake, indexer),
        //             new InstantCommand(() -> m_drivetrain.resetOdometry(new Pose2d(0, 0, new Rotation2d(0)))).andThen(
        //                 getSegment(
        //                     new Pose2d(0, 0, new Rotation2d(0)),
        //                     new Pose2d(7.6, 1.4, new Rotation2d(0)),
        //                     List.of(new Translation2d(1,0), new Translation2d(2.6,-0.5), new Translation2d(3.5,1.1)),
        //                     false
        //                 )
        //             )
        //         )
        //     );
        // }
        // else if (filename.equals("galacticRedB")) {
        //     addCommands(
        //         parallel(
        //             factory.getIntakeIndexer(intake, indexer),
        //             new InstantCommand(() -> m_drivetrain.resetOdometry(new Pose2d(0, 0, new Rotation2d(0)))).andThen(
        //                 getSegment(
        //                     new Pose2d(0, 0, new Rotation2d(0)),
        //                     new Pose2d(7.6, 0.8, new Rotation2d(0)),
        //                     List.of(new Translation2d(1.5,0.8), new Translation2d(3,-0.8), new Translation2d(4.5, 0.5)),
        //                     false
        //                 )
        //             )
        //         )
        //     );
        // }
        // else if (filename.equals("galacticBlueA")) {
        //     addCommands(
        //         parallel(
        //             factory.getIntakeIndexer(intake, indexer),
        //             new InstantCommand(() -> m_drivetrain.resetOdometry(new Pose2d(0, 0, new Rotation2d(0)))).andThen(
        //                 getSegment(
        //                     new Pose2d(0, 0, new Rotation2d(0)),
        //                     new Pose2d(7.6, -0.8, new Rotation2d(-Math.PI/4)),
        //                     List.of(new Translation2d(3.8, -1.4), new Translation2d(4.5, 0.8), new Translation2d(6.1, 0)),
        //                     false
        //                 )
        //             )
        //         )
        //     );
        // }
        // else if (filename.equals("galacticBlueB")) {
        //     addCommands(
        //         parallel(
        //             factory.getIntakeIndexer(intake, indexer),
        //             new InstantCommand(() -> m_drivetrain.resetOdometry(new Pose2d(0, 0, new Rotation2d(0)))).andThen(
        //                 getSegment(
        //                     new Pose2d(0, 0, new Rotation2d(0)),
        //                     // new Pose2d(7.6, 1.6, new Rotation2d(-Math.PI/4)),
        //                     new Pose2d(8, -0.8, new Rotation2d(0)),
        //                     List.of(
        //                         new Translation2d(3.8, -0.7),
        //                         new Translation2d(5.5, 0.7),
        //                         new Translation2d(7, -0.9)
        //                     ),
        //                     false
        //                 )
        //             )
        //         )
        //     );
        // }
        // else {
        //     addCommands(
        //         getSegment(
        //             new Pose2d(0, 0, new Rotation2d(0)),
        //             new Pose2d(1, 0, new Rotation2d(0)),
        //             List.of(),
        //             false
        //         )
        //     );
        // }
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }

    private Command getSegment(Pose2d origin, Pose2d end, List<Translation2d> cords, boolean reversed) {
        var autoVoltageConstraint =
            new DifferentialDriveVoltageConstraint(
                new SimpleMotorFeedforward(
                    DriveConstants.ksVolts, 
                    DriveConstants.kvVoltSecondsPerMeter, 
                    DriveConstants.kaVoltSecondsSquaredPerMeter),
                DriveConstants.kDriveKinematics,
                10);

        TrajectoryConfig config =
            new TrajectoryConfig(VELOCITY, ACCELERATION)
                .setKinematics(DriveConstants.kDriveKinematics)
                .addConstraint(autoVoltageConstraint)
                .setReversed(reversed);
        
        Trajectory trajectory = TrajectoryGenerator.generateTrajectory(
            origin, cords, end, config);
        
        RamseteCommand ramseteCommand = new RamseteCommand(
            trajectory,
            m_drivetrain::getPose,
            new RamseteController(AutoConstants.kRamseteB, AutoConstants.kRamseteZeta),
            new SimpleMotorFeedforward(DriveConstants.ksVolts, DriveConstants.kvVoltSecondsPerMeter, DriveConstants.kaVoltSecondsSquaredPerMeter),
            DriveConstants.kDriveKinematics,
            m_drivetrain::getWheelSpeeds,
            new PIDController(DriveConstants.kPDriveVel, 0, 0),
            new PIDController(DriveConstants.kPDriveVel, 0, 0),
            m_drivetrain::tankDriveVolts,
            m_drivetrain);
    
        m_drivetrain.resetOdometry(trajectory.getInitialPose());
        return ramseteCommand;
    }
    
}